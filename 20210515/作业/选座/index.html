<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>


    <script>

        /**5.最大数量气球：给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的
         * 单词 "balloon"（气球）。字符串 text 中的每个字母最多只能被使用一次。
         * 请你返回最多可以拼凑出多少个单词 "balloon"。
        如：输入：text = "loonbalxballpoon"   输出：2
        输入：text = "nlaebolko"           输出：1
         * 
        */
       //分别计每次字母出现的数
        var count1 = 0, count2 = 0, count3 = 0, count4 = 0, count5 = 0;
        // var text = "loonbalxballpoon" ;
        // var  text = "nlaebolko" 
        var text = "adgewasfsdweg";
        var arr = text.split("");
        for (var i = 0; i < arr.length; i++) {
            //遍历数组每次字母出现了就加一
            if (arr[i] == "b") {
                count1++;
            }
            if (arr[i] == "a") {
                count2++;
            }
            if (arr[i] == "l") {
                count3++;
            }
            if (arr[i] == "o") {
                count4++;
            }
            if (arr[i] == "n") {
                count5++;
            }
        }
        //取出现次数的最小值，就是单词出现次数。a:1 b:1 l:2 o:2 n:1的时候表示一次，所以 l，o要除以2.
        //只要这些都满足的情况下菜表示出现了依次单词。
        var count = Math.min(count1, count2, parseInt(count3 / 2), parseInt(count4 / 2), count5);
        console.log(count)



        /**6.旅行终点站：给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，
         * 其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。
         * 请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。
         * 题目数据保证线路图会形成一条不存在循环的线路，因此只会有一个旅行终点 。
如：输入：paths = [["London","New York"],["New York","Lima"],["Lima","Sao Paulo"]]   
输出："Sao Paulo" 
         * 
        
        */
        var first = [];
        var last = [];
        var result = [];
        var qidian;
        var paths = [["London", "New York"], ["New York", "Lima"], ["Lima", "Sao Paulo"]];
        for (var i = 0; i < paths.length; i++) {
            //分别把二维数组的地一位和第二位分别存入两个一维数组，再拼成一个新数组
            first.push(paths[i][0]);
            qidian = first[0];
            last.push(paths[i][1]);
            var newr = first.concat(last);
        }

        for (var j = 0; j < newr.length; j++) {
            //如果两个的下标相同就表示只出现了一次，因为中间的都出现了两次，出现一次只能是起点和终点，判断不等于起点时，输出就是终点。
                if (newr.indexOf(newr[j]) == newr.lastIndexOf(newr[j])) {
                    if(newr[j]!=qidian){
                        result.push(newr[j])
                    }
                }
            }
    </script>
</body>

</html>